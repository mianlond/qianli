<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/react/18.2.0/umd/react.production.min.js"></script>
    <script
        src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/babel-standalone/6.26.0/babel.min.js"></script>
</head>

<body>
    <label for="quota">素数个数：</label>
    <input type="text" id="quota" name="quota" value="1000000" />

    <button id="generate">生成素数</button>
    <button id="reload">重载</button>

    <div id="output"></div>

    <script type="text/babel">

        //同步编程
        // const name = "Maker";
        // const greeting = `I'm ${name}`;
        // console.log(greeting);

        function makeGreeting(name) {
            return `Hello, my name is ${name}!`;
        }
        const name = "Miriam";
        const greeting = makeGreeting(name);
        console.log(greeting); // "Hello, my name is Miriam!"


        // 生成素数  慢
        /*
        function generatePrimes(quota) {
            function isPrime(n) {
                for (let c = 2; c <= Math.sqrt(n); ++c) {
                    if (n % c === 0) {
                        return false;
                    }
                }
                return true;
            }
            const primes = [];
            const maximum = 1000000;
            while (primes.length < quota) {
                const candidate = Math.floor(Math.random() * (maximum + 1));
                if (isPrime(candidate)) {
                    primes.push(candidate);
                }
            }
            return primes;
        }
        document.querySelector("#generate").addEventListener("click", () => {
            const quota = document.querySelector("#quota").value;
            const primes = generatePrimes(quota);
            document.querySelector("#output").textContent =
                `完成！已生成素数${quota}个。`;
        });
        document.querySelector("#reload").addEventListener("click", () => {
            document.location.reload();
        });
        */

        // fetch() API
        const fetchPromise = fetch(
            "https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json",
        );

        console.log(fetchPromise);

        fetchPromise.then((response) => {
            console.log(`已收到响应：${response.status}`); // 200
        });

        console.log("已发送请求……");




    </script>

</body>
<!-- AI 
异步JavaScript（Asynchronous JavaScript）是指在JavaScript中处理异步操作的方式和模式。
异步编程允许JavaScript代码在等待某些操作完成（如网络请求、文件读写、定时器等）时，不会阻塞其他代码的执行。
这对于提高应用程序的性能和响应性至关重要，尤其是在处理I/O操作（输入/输出）时。

以下是JavaScript中处理异步操作的一些常见方法：

1. **回调函数（Callback Functions）**：
   - 最早的异步处理方式，将函数作为参数传递给另一个函数，在某个操作完成时被调用。
   - 缺点是可能导致“回调地狱”（Callback Hell），即嵌套的回调函数难以阅读和维护。

   ```javascript
   setTimeout(function() {
       console.log('Hello, World!');
   }, 1000);
   ```

2. **Promises**：
   - 允许你为异步操作写线性、同步的代码，而实际上执行的是异步的。
   - 通过`.then()`、`.catch()`和`.finally()`方法处理成功、失败和完成的状态。

   ```javascript
   fetch('https://api.example.com/data')
       .then(response => response.json())
       .then(data => console.log(data))
       .catch(error => console.error('Error:', error));
   ```

3. **async/await**：
   - 基于Promises，提供了一种更简洁、更直观的方式来处理异步操作。
   - `async`关键字用于声明一个函数是异步的，`await`关键字用于等待一个Promise解决。

   ```javascript
   async function fetchData() {
       try {
           const response = await fetch('https://api.example.com/data');
           const data = await response.json();
           console.log(data);
       } catch (error) {
           console.error('Error:', error);
       }
   }
   ```

4. **事件监听器（Event Listeners）**：
   - 用于监听和响应DOM事件（如点击、滚动、键盘事件等）。

   ```javascript
   document.getElementById('myButton').addEventListener('click', function() {
       console.log('Button clicked!');
   });
   ```

5. **Observables（可观察对象）**：
   - 一种更高级的异步处理方式，允许你订阅和监听数据流。
   - 在RxJS（Reactive Extensions for JavaScript）等库中实现。

   ```javascript
   const { Observable } = rxjs;
   const source$ = new Observable(subscriber => {
       subscriber.next('Hello');
       subscriber.next('World');
       subscriber.complete();
   });

   source$.subscribe(value => console.log(value));
   ```

6. **Worker Threads**：
   - 允许你创建后台线程来执行代码，避免阻塞主线程。
   - 适用于密集型计算任务。

   ```javascript
   const worker = new Worker('worker.js');
   worker.onmessage = function(e) {
       console.log('Message received from worker:', e.data);
   };
   worker.postMessage('Hello, worker!');
   ```

异步JavaScript是现代Web开发中的一个重要概念，它使得开发者能够创建响应迅速、用户体验良好的应用程序。
随着JavaScript语言和相关工具的发展，异步编程的模式也在不断演进。
 -->

</html>